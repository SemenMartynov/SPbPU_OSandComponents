\newpage
\section{Виды обфускации}

Обфускация имеет под собой серьёзные теоретические основания. Важно не только выполнить основную задачу -- запутать код, но и при этом не нанести серьёзного урона как скорости, так и функциональности приложения.

Наибольшую популярность в деле обфускации получил метод Колберга. Пусть программа -- А, тогда задача сводится к созданию выходного кода $A`$ с использованием преобразований $T_1, T_2 \dots T_n$, опирающихся на использование библиотек $L_1, L_2 \dots L_n$. Эффективность процессов оценивается функциями $E_1, E_2 \dots E_n$. Множественность возникает из-за разбиения кода на разные по важности фрагменты, оцениваемые функциями $I_1, I_2 \dots I_n$. Так мы обеспечим максимальную защиту важнейшим участкам, при этом постараюсь не проиграть в быстродействии.

Преобразования бывают четырех видов:

\begin{itemize}
\item лексическая обфускация;
\item преобразование данных;
\item преобразование управления;
\item профилактическая обфускация.
\end{itemize}

\subsection{Лексическая обфускация}

Наиболее простая, заключается в форматировании кода программы, изменении его структуры, таким образом, чтобы он стал нечитабельным, менее информативным, и трудным для изучения.

Обфускация такого вида включает в себя:
\begin{itemize}
\item удаление всех комментариев в коде программы, или изменение их на дезинформирующие
\item удаление различных пробелов, отступов которые обычно используют для лучшего визуального восприятия кода программы
\item замену имен идентификаторов (имен переменных, массивов, структур, хешей, функций, процедур и т.д.), на произвольные длинные наборы символов, которые трудно воспринимать человеку
\item добавление различных лишних (мусорных) операций
\item изменение расположения блоков (функций, процедур) программы, таким образом, чтобы это не коим образом не повлияло на ее работоспособность.
\end{itemize}

Изменение глобальных имён идентификаторов следует производить в каждой единице трансляции (один файл исходного кода), так чтобы они имели одинаковые имена (в противном случае защищаемая программа может стать не функциональной). Также следует учитывать специфические идентификаторы, принятые в том языке программирования, на котором написана защищаемая программа, имена таких идентификаторов, лучше не изменять.

Можно рассмотреть пример кода:

\begin{Verbatim}[frame=single]
int counter;
bool alarm;

for (counter = 0; counter < 100; counter++)
{
  if (counter == 99)
  {
    alarm = true;
  }
}
\end{Verbatim}

После процесса лексической обфускации будет получено следующее

\begin{Verbatim}[frame=single]
int plf5ojvb; bool jht4hnv; for(plf5ojvb=0; plf5ojvb<100; plf5ojvb++){if
(plf5ojvb==99) jht4hnv=true;)
\end{Verbatim}

Читать и понимать такой код становится сложнее с числом роста переменных.

Ниже представлен ещё один пример фрагмента исходного кода программы (написанной на Perl), до и после прохождения лексической обфускации.

До лексической обфускации: 

\begin{Verbatim}[frame=single]
my $filter; 

if (@pod) {
 my ($buffd, $buffer) = File::Temp::tempfile(UNLINK => 1);
 print $buffd "";
 print $buffd @pod	or die "";
 print $buffd 
 close $buffd	or die "";
 @found = $buffer;
$filter = 1;
}
exit;

sub is_tainted {
my $arg = shift;
my $nada = substr($arg, 0, 0);  # zero-length
local $@;  # preserve caller's version
eval { eval "#" };
return length($@) != 0;
}

sub am_taint_checking {
my($k,$v) = each %ENV;
return is_tainted($v);  
}
\end{Verbatim}

После лексической обфускации:

\begin{Verbatim}[frame=single]
sub z109276e1f2 { ( my $z4fe8df46b1 = shift ( @_ ) ) ; ( my      
$zf6f94df7a7 = substr ( $z4fe8df46b1 , 
(0x1eb9+ 765-0x21b6) , (0x0849+ 1465-0x0e02) ) ) ; local $@ ;
eval { eval ( ( 
"" ) ) ; } ; return ( ( length ( $@ ) != (0x26d2+  59-0x270d) ) )
; } my ( $z9e5935eea4 ) ; if ( @z6a703c020a ) { ( my (
$z5a5fa8125d , $zcc158ad3e0 ) = 
File::Temp::tempfile ( "" , (0x196a+ 130-0x19eb) ) ) ; print (
$z5a5fa8125d "" ) ; ( print ( $z5a5fa8125d @z6a703c020a 
) or die ( ( ( ( "" . $zcc158ad3e0 ) . "\x3a\x20" ) . $! ) ) ) ;
print ( $z5a5fa8125d "" ) ; ( close ( $z5a5fa8125d ) or die ( ( (
( "" ) ) ) ; ( @z8374cc586e = $zcc158ad3e0 ) ; ( $z9e5935eea4 = 
(0x1209+ 1039-0x1617) ) ; } exit ; sub z021c43d5f3 { ( my (
$z0f1649f7b5 , $z9e1f91fa38 ) = each ( %ENV ) ) ; return (
z109276e1f2 ( $z9e1f91fa38 ) ) ; }
\end{Verbatim}

Данная обфускация программного кода, по сравнению с остальными, позволяет сравнительно быстро привести исходный код программы, в нечитабельное состояние. Один из ее недостатков состоит в том, что она эффективна только для осуществления высокоуровневой обфускации. Современные IDE умеют искать использования методов в коде, это очень упрощает анализ обфусцированного кода. Обход такой обфускации вопрос времени.

\subsection{Обфускация данных}

Такая обфускация связана с трансформацией структур данных. Она считается более сложной, и является наиболее продвинутой и часто используемой. Ее принято делить на три основные группы, которые описаны ниже.


\subsubsection{Обфускация хранения}

Заключается в трансформации хранилищ данных, а также самих типов данных (например, создание и использование необычных типов данных, изменение представления существующих и т.д.).

К этой группе относится изменение интерпретации данных определенного типа. Как известно сохранение, каких либо данных в хранилищах (переменных, массивах и т.д.) определенного типа (целое число, символ) в процессе работы программы, очень распространенное явление. Например, для перемещения по элементам массива очень часто используют переменную типа "целое число", которая выступает в роли индекса. Использование в данном случае переменных иного типа возможно, но это будет не тривиально и может быть менее эффективно. Интерпретация комбинаций разрядов содержащихся в хранилище данных осуществляется в зависимости от его типа. Так, например, можно сказать, что 16-разрядная переменная целого типа содержащая комбинации разрядов 0000000000001100 представляет целое число 12, но это простое соглашение, данные в такой переменной можно интерпретировать по-разному (не обязательно как 12, а, например как 1100 и т.д.).

Статических (неменяющихся) данные преобразуются в процедурные. Большинство программ, в процессе работы, выводят различную информацию, которая чаще всего в коде программы представляется в виде статических данных таких как строки, которые позволяют визуально ориентироваться в ее коде и определять выполняемые операции. Такие строки также желательно предать обфускации, это можно сделать, просто записывая каждый символ строки, используя его ASCII код, например символ "A" можно записать как 16-ричное число "0х41", но такой метод банален. Наиболее эффективный метод, это когда в код программы в процессе осуществления обфусации добавляется функция, генерирующая требуемую строку в соответствии с переданными ей аргументами, после этого строки в этом коде удаляются, и на их место записывается вызов этой функции с соответствующими аргументами.

Переменные фиксированного диапазона могут быть разделены на две и более переменных. Для этого переменную "V" имеющую тип "x" разделяют на "k" переменных "v1,...,vk" типа "y" то есть "V == v1,...,vk". Потом создается набор функций позволяющих извлекать переменную типа "x" из переменных типа "y" и записывать переменную типа "x" в переменные типа "y".

Изменение представления (или кодирование). Например, целочисленную переменную "i", можно заменить, выражением "i` = c1*i + c2" где "c1,c2" являются константами.

\subsubsection{Обфускация соединения}

Один из важных этапов, в процессе реверсивной инженерии программ, основан на изучении структур данных. Поэтому важно постараться, в процессе обфускации, усложнить представление используемых программой структур данных. Например, при использовании обфускации соединения это достигается благодаря соединению независимых данных, или разделению зависимых.

Две или более переменных "v1,...,vk" могут быть объединены в одну переменную "V", если их общий размер ("v1,...,vk") не превышает размер переменной "V". Например, рассмотрим простой пример объединения двух коротких целочисленных переменных "X","Y" (размером 16 бит) в одну целочисленную переменную "Z" (размером 32 бита).

Реструктурирование массивов, заключается в запутывании структуры массивов, путем разделения одного массива на несколько подмассивов, объединения нескольких массивов в один, сворачивания массива (увеличивая его размерность) и наоборот, разворачивая (уменьшая его размерность). Например, один массив "@A" можно разделить на несколько подмассивов "@A1, @A2", при этом один массив "@A1" будет содержать четные позиции элементов, а второй "@A2" нечетные позиции элементов массива "@A".

Изменение иерархий наследования классов, осуществляется путем усложнения иерархии наследования при помощи создания дополнительных классов или использования ложного разделения классов. 

\subsubsection{Обфускация переупорядочивания}
Заключается в изменении последовательности объявления переменных, внутреннего расположения хранилищ данных, а также переупорядочивании методов, массивов (использование нетривиального представления многомерных массивов), определенных полей в структурах и т.д. 

\subsection{Обфускация управления}

Обфускация такого вида осуществляет запутывание потока управления, то есть последовательности выполнения программного кода.

Большинство ее реализаций основывается на использовании непрозрачных предикат, в качестве, которых выступают, последовательности операций, результат работы которых сложно определить (само понятие "предикат" выражает свойство одного объекта (аргумента), или отношения между несколькими объектами).

Определение. Предикат "Р" считается непрозрачным предикатом, если его результат известен только в процессе обфускации, то есть после осуществления процесса обфускации, определение значения такого предиката, становится трудным.

Обозначим непрозрачный предикат, возвращающий всегда значение TRUE как "Р(t)", а возвращающий значение FALSE, как "Р(f)", тогда непрозрачный предикат, который может возвратить любое из этих двух значений (то есть или TRUE, или FALSE, что нам неизвестно) как "Р(t,f)". Эти обозначения, будут использоваться дальше в контексте описания обфускации управления. Непрозрачные предикаты могут быть:

\begin{itemize}
\item локальными - вычисления содержаться внутри одиночного выражения (условия)
\item глобальными - вычисления содержаться внутри одной процедуры (функции)
\item межпроцедурными - вычисления содержаться внутри различных процедур (функций)
\end{itemize}

Эффективность обфускации управления в основном зависит от используемых непрозрачных предикат, это вынуждает создавать как можно сложные для изучения, и простые, гибкие в использовании непрозрачные предикаты, но в равной степени также не маловажную роль имеет время их выполнения, а также количество выполняемых операций, помимо всего этого предикат не сильно должен отличаться от тех функций, которые выполняет сама программа, и не должен содержать чрезмерное количество вычислений, в противном же случае злоумышленник, сможет сразу его обнаружить. Так как часто для деобфускации используют технологию статического анализа, а одним из ее недостатков является сложность (трудоемкость) статического анализа структур указателей, то обычно в процессе обфускации управления используют устойчивые непрозрачные предикаты, которые позволяют использовать недостатки технологии статического анализа.

Основная идея устойчивых непрозрачных предикатов состоит в том, что в программу, в процессе обфускации добавляется код, который создает набор динамических структур, а также глобальных указателей, которые будут ссылаться на различные элементы внутри этих структур. Помимо этого, данный код должен иногда обновлять эти структуры (добавлять новые элементы в них, объединять или разделять некоторые их них, изменять значения глобальных указателей, и т.д.), но таким образом, чтобы при этом были сохранены некоторые условия, например "указатель p и q никогда не будут указывать на один и тот же элемент" или "указатель p может ссылаться (указывать) на указатель q" и т.д. Эти условия в последствии позволяют создавать требуемые непрозрачные предикаты.

Таких манипуляций с указателями, и структурами, можно делать очень много, они могут быть добавлены в разные участки программы, и их можно усложнить, а также добавить какие-то уникальные процедуры для работы со структурами. При этом существующие алгоритмы статического анализа становятся не эффективны.

Методы позволяющие осуществить обфускацию управления, классифицируются на три основных группы: 

\subsubsection{Обфускация вычислительная}

Изменение касающиеся главной структуры потока управления. К ним можно отнести:

\begin{itemize}
\item расширения условий циклов. Для этого обычно используют непрозрачные предикаты, таким образом, чтобы они не коим образом не влияли на количество выполнений циклического кода.
\item добавления недостижимого кода, (который не будет выполняться в процессе работы программы)
\item устранение библиотечных вызовов. Большинство программ, используют функции, которые определены в стандартных библиотеках исходного языка, на котором писалась программа (например, в Си это библиотека "libc"), работа таких функции хорошо документирована и часто известна злоумышленникам, следовательно, их присутствие в коде программы, может помочь в процессе ее реверсивной инженерии. Поэтому имена функций из стандартных библиотек, также желательно придать обфускации, т.е. изменить на наиболее бессмысленные, которые потом будут фигурировать в коде защищаемой программы.
\item добавление избыточных операций (мертвого кода) в те участки программного кода, которые наиболее трудные (изначально) для изучения. Часто избыточные операции, используются для расширения арифметических выражений (например, в непрозрачных предикатах).
\item параллелизирование кода, заключается в разделении кода на отдельные независимые участки, которые во время работы программы будут выполняться параллельно (т.е. одновременно), такая обфускация также может заключаться в импровизации параллелизирования кода программы, для это создается так называемый макет процесса, который на самом деле не будет выполнять не каких полезных операций. 
\end{itemize}

\subsubsection{Обфускация соединения}

Объединение или разделение определенных фрагментов кода программы, для того чтобы убрать логические связи между ними. Ниже приведены основные методы, позволяющие осуществить такую обфускацию:

\begin{itemize}
\item встраивание функций, осуществляется путем встраивания кода функции, в места ее вызова (если ее код будет встроен во все места ее вызова, тогда саму функцию можно убрать из кода программы). 
\item извлечение функций, является обратным действием, по отношению к встраиванию функций. Осуществляется в результате объединения некоторой группы взаимосвязанных операторов в коде исходной программы в отдельную функцию (при необходимости для этой функции можно определить некоторые аргументы), которой потом замещают эти группы операторов. Но следует учесть, что такое преобразование может быть снято компилятором в процессе компиляции кода программы.
\item чередование, объединение фрагментов кода программы (функций например), выполняющих различные операции, воедино (в одну функцию, при этом в такую функцию, следует добавить объект, в зависимости от значения которого, будет выполняться код одной из объединенных функций).
\item клонирование, данный метод позволяет усложнить анализ контекста использования функций, и объектов используемых в коде исходной программы. Процесс клонирования функций состоит в выделении определенной функции "F", часто используемой в коде программы, после чего над кодом этой функции осуществляется трансформация, и создается ее клон "F`", который также будет добавлен в код исходной программы, при этом часть вызовов функции "F" в коде исходной программы, будет замещена на вызов функции "F`". В результате этого у злоумышленника создастся представление о том, что функции "F", и "F`" различны. Клонирование объектов осуществляется аналогичным способом.
\item трансформация циклов. Циклы встречаются в коде различных программ, и их также можно придать трансформации. Блокирование циклов, заключается в добавлении вложенных циклов в существующие, в результате работа существующих циклов будет заблокирована, на какой-то диапазон значений.
\item Развертка циклов, повторение тела цикла один или более раз (если количество выполняемых циклов известно в процессе осуществления обфускации (например, равно "N"), то цикл, может быть, развернут полностью, в результате повторения его тела в коде N раз)
\item Разделение циклов, цикл состоящий из более чем одной независимой операции можно разбить на несколько циклов (которые должны выполняться одинаковое количество раз), предварительно разбив на несколько частей, его тело.
\end{itemize}

\subsubsection{Обфускация последовательность}
Заключается в переупорядочивании блоков (инструкций переходов), циклов, выражений. 

\subsection{Превентивная обфускация}

Защищает код от деобфускации специальными программами-деобфускаторами. Они основываются на обнаружении неиспользуемых кусков кода, нахождении наиболее сложных структур (фрагментов максимальной важности) и анализе статистических и динамических данных. Именно борьба с этими операциями -- наиболее сложный и эффективный процесс обфускации. Здесь необходимо максимально точно подойти к анализу исходных данных, задействовать максимум предоставленных ресурсов, учесть подходы потенциальных оппонентов.