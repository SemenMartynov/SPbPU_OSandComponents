\newpage
\section*{Введение}
\addcontentsline{toc}{section}{Введение}

Реверс-инжиниринг ПО (обратный инжиниринг, обратная разработка) это процесс восстановления структуры, внутреннего устройства программы с целью понимания его принципа её работы.

Мотивацией проведения реверс-инжиниринга может являться извлечение спецификации, моделей (выявление архитектуры программы, получение алгоритмов работы, извлечение поведенческих моделей), понимание работы программы, деобфускация или даже восстановление исходного кода. Необходимость в реверс-инжиниринг может возникнуть когда возникают задачи поддержки legacy кода, при подготовке к реинжинирингу либо когда нужно скопировать какую-то функциональность ПО без нарушения авторских прав. Последний пункт требует отдельного изучения, т.к. иногда производитель ПО сопровождает свой продукт лицензией не допускающей его реверс-инжиниринга (к примеру Skype).

Предметом анализа реверс-инжиниринга обычно является:
\begin{itemize}
\item Исходный код ПО
\item Бинарный код ПО
\item Байт-код
\item Программная документация
\end{itemize}

Результатом проведения реверс-инжиниринга может быть:
\begin{itemize}
\item Диаграммы классов
\item Диаграммы компонентов
\item Диаграммы модулей
\item Диаграммы состояний
\item Диаграммы последовательностей
\item Схемы алгоритмов
\item Модели данных
\item Протокол исследования
\item Любые другие текстовые и графические данные, соответствующие поставленной задаче
\end{itemize}

В зависимости от цели и от того, что есть в наличии у исследователя можно выбрать соответствующий инструмент. К примеру, если есть исходный код какого-то протокола обмена, то средствами статического анализа (метод обратной трассировки) можно получить диаграмму состояний. Если есть бинарный (исполняемый) код, то можно провести динамический анализ -- запротоколировать и визуализировать трассы исполнения.

В данной работе мы проведём реверс-инжиниринг свободной (лицензия BSD) Unix-подобной микроядерной операционной системы Minix. Изначально (1987 год) ядро Minix состояло из 1 600 строк на С и 800 ассемблерных строк. Ко второй версии (1997 год) ее размер вырос до 62 200 строк. На данный момент последней стабильной версией является 3.3.0 (16 сентября 2014) и её объём составляет 1 415 811 строк в .c и .h файлах.

Нашей целью является реверс-инжиниринг текущей версии Minix для быстрой ориентации по исходному коду. Нами будет рассмотрено микроядро (директория /kernel), серверы (директория /servers), некоторые включаемые файлы (директория /include/), системный загрузчик (директория /boot). Из рассмотрения были исключены системные и пользовательские библиотеки (директория /lib), тесты (директория /test) и системные утилиты (директория /commands) т.к. они не являются частями собственно операционной системы. Драйверы содержат много специфичной информации, а вспомогательные файлы (директории /etc/ и /tools/) не требуют особых пояснений. Так же была исключён раздел с документацией (директории /man/ и /docs/) т.к. они не содержат файлов с исходным кодом.

В своей работе мы будем использовать стандартные инструменты разработчика -- утилиты grep, find, cat и редактор vim с набором плагинов для подсветки кода.