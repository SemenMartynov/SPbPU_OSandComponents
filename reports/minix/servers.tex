\newpage
\section{Серверы}

\subsection{Виртуальная файловая система /servers/vfs}

Виртуальная файловая система (virtual file system -- VFS) -- уровень абстракции поверх конкретной реализации файловой системы. Целью VFS является обеспечение единообразного доступа клиентских приложений к различным типам файловых систем. VFS может быть использована, например, для прозрачного доступа к локальным и сетевым устройствам хранения данных без использования специального клиентского приложения (независимо от типа файловой системы). VFS определяет интерфейс между ядром и конкретной файловой системой, таким образом, можно легко добавлять поддержку новых типов файловых систем, внося изменения только в ядро операционной системы.

\textbf{const.h} -- Содержит различные константы:
\begin{itemize}
\item размеры таблиц (filp , file locking , mount , vnode);
\item uid\_t суперпользователя MM и INIT, uid\_t для которого разрешена FSSIGNON, gid\_t  MM и INIT;
\item константы для определения блокировок;
\item для аргументов: LOOK\_UP, ENTER, DELETE, IS\_EMPTY, DUP\_MASK, SYMLOOP, ROOT\_INODE;
\item константы -- аргументы для dev\_io : VFS\_DEV\_(READ, WRITE, SCATTER, GATHER, IOCTL, SELECT);
\end{itemize}

Макросы: fp\_is\_blocked(fp)

\textbf{device.c} -- Когда необходимый блок не находится в кэше, он должен быть получен из диска. Специальные символьные файлы также нуждаются в вводе/выводе. В данном файле находятся необходимые для этого процедуры.

Точки входа данного файла:
\begin{itemize}
\item для операций с устройствами (dev\_open, dev\_close, dev\_io, dev\_statu);
\item общие операции (gen\_opcl, gen\_io);
\item операции для несуществующих устройств: (no\_dev, no\_dev\_io);
\item для tty-устройств (tty\_opcl, ctty\_opcl, ctty\_io);
\item для системных вызовов (do\_ioctl, do\_setsid).
\end{itemize}

\textbf{dmap.h} -- Таблица устройств: устройство -- драйвер.

Индексами таблицы являются главный номер устройства. Таблица обеспечивает связь между главным номером устройства и процедурами, которые обеспечивают его функционирование. Таблица может быть дополнена динамически.

Содержит константы-флаги: DMAP\_MUTABLE, DMAP\_BUSY, DMAP\_BABY.

\textbf{dmap.c} -- Этот файл содержит таблицу: устройство - таблица драйверов.

В нём также содержаться некоторые процедуры для динамического добавления, удаления драйверов, а также изменения связей. Интерес представляет начальная инициализация init\_dmap[] , содержащая устройства ((/dev/)mem, fd0, c0, tty00, tty, lp, ip, c1, c2, c3, audio, klog, random).

\textbf{exec.c} -- Этот файл обеспечивает системный вызов EXEC (замены контекста процесса).

Порядок работы:
\begin{itemize}
\item проверяет разрешение файла на исполнение,
\item читает заголовок и определяет размеры,
\item получает начальные аргументы и переменные окружения из пространства пользователя,
\item выделяет память для нового процесса,
\item копирует начальный стек из сервера управления процессами (PM) в данный процесс,
\item читает сегменты кода и данных и копирует их в данный процесс,
\item устанавливает биты setuid, setgid,
\item изменяет таблицу 'mproc',
\item сообщает микроядру о EXEC,
\item сохраняет смещение на начальные аргументы.
\end{itemize}

\textbf{file.h} -- Таблица-прослойка между дескрипторами файлов и айнодами ФС.

\textbf{filedes.c} -- Содержит процедуры для манипуляций с файловыми дескрипторами.

\textbf{fproc.h} -- Это информация для каждого процесса. Слот резервируется для каждого потенциального процесса. Именно поэтому константа NR\_PROCS должна соответствовать конфигурации микроядра.

\textbf{fs.h} -- Базовый заголовочный файл для файловой системы. Он включает несколько иных файлов и определяет принципиальные константы -- константы режима компиляции (для библиотечных включаемых файлов).

\textbf{fscall.c} -- Этот файл обеспечивает вложенные контр-запросы серверу виртуальной файловой системы (VFS), посылаемые файловыми серверами в ответ на запрос сервера VFS.

\textbf{glo.h} --  определения глобальных переменных виртуальной файловой системы (реально выделяются в файле table.o данной подсистемы).

Также содержит переменные в которых сохраняются параметры вызова, возвращаемого результата (код ошибки), а также объявлены некоторые данные, которые инициализируются в другом месте
\begin{Verbatim}[frame=single]
(_PROTOTYPE (int (*call_vec[]), (void) ); /* sys call table */,
char dot1[2]; /* dot1 (&dot1[0]) and dot2 (&dot2[0]) have a special */
char dot2[3];   /* meaning to search_dir: no access permission check. */)
\end{Verbatim}

\textbf{link.c} -- Этот файл обеспечивает системные вызовы LINK и UNLINK. Здесь также обеспечивается освобождение памяти, когда когда выполняется последний UNLINK и блоки должны быть возвращены в пул свободных блоков.

\textbf{lock.h} -- Таблица блокировок файлов. Она указывает на таблицу айнод, однако в данном случае для получения информации о блокировках. Конкретно определяет только один массив: file\_lock[NR\_LOCKS];

\textbf{lock.c} -- Обеспечивает предусмотренную стандартом POSIX систему блокировки файлов.

\textbf{main.c} -- Стандартный файл для всех серверов и драйверов, в котором находится бесконечный цикл, получающий сообщения о запросах на выполнения операций, обрабатывающий эти запросы соответствующим образом, а также возвращающим необходимые ответы.

\textbf{misc.c} -- Этот файл содержит набор различных процедур. Некоторые из них выполняют простейшие системные вызовы. Другие выполняют небольшую часть работы. Связанной с системными вызовами, основную часть которых выполняет сервер управления памятью (MM и VM).

Точки входа:
\begin{itemize}
\item do\_dup -- выполняет системный вызов DUP
\item do\_fcntl -- выполняет системный вызов FCNTL
\item do\_sync -- выполняет системный вызов SYNC
\item do\_fsync --  выполняет системный вызов FSYNC
\item do\_reboot -- обновляет диск с буферов в рамках подготовки к завершению работы системы
\item do\_fork -- выполняет записи в таблицах VFS после выполнения системного вызова FORK
\item do\_exec -- обеспечивает файлы с установленным флагом FD\_CLOEXEC после выполнения системного вызова EXEC
\item do\_exit -- выполняет записи в таблицах, связанные с завершением процесса
\item do\_set -- устанавливает uid или gid для некоторого процесса
\item do\_revive -- пересматривает процессы (с целью некоторых действий), которые ожидают события в файловой системе (вроде TTY)
\item do\_svrctl -- контроль файловой системы
\item do\_getsysinfo -- выдаёт копию структур данных файловой системы
\item pm\_dumpcore -- выполняет дамп памяти
\end{itemize}

\textbf{mmap.c} -- Обеспечение функционала mmap в VFS. Точка входа do\_vm\_mmap -- сервер виртуальной памяти вызывает VM\_VFS\_MMAP.

\textbf{mount.c} -- Обеспечивает системные вызовы MOUNT и UMOUNT.

\textbf{open.c} -- Этот файл содержит процедуры для создания, открытия, закрытия и изменения позиции "курсора текущей позиции" файла.

\textbf{param.h} -- Устанавливает внутренние синонимы с полями в структурах входящих сообщений, а также синонимы в полях исходящих сообщений.

\textbf{path.c} -- Основная процедура Lookup(), контролирующая нахождение имени пути (файла, папки или другого файлового объекта). Она поддерживает точки монтирования и символические ссылки. Настоящий запрос на поиск посылается через функцию-обёртку req\_lookup.

\textbf{pipe.c} -- Функция обеспечивает приостановку и возобновление исполнения процесса (связанные с операциями с файловым объектом pipe).

\textbf{proto.h} -- Содержит все прототипы функций подсистемы (с комментариями, указывающими на местонахождение этих функций -- файл подсистемы, в котором реализован данный набор функций).

\textbf{read.c} -- В этом файле находится механизм чтения и записи файла. Запросы на чтение и запись разделены между собой по чанкам которые не пересекают границы блока (диска). Каждый чанк обрабатывается в один ход. Чтение специальных файлов также определяется и поддерживается.

\textbf{request.h} -- Низкоуровневые сообщения-запросы строятся и посылаются посредством функций-обёрток. Этот файл содержит описания структур запросов и ответов, используемых для доступа к этим функциям-обёркам.

\textbf{request.c} -- Этот файл содержит функции-обёртки для подачи запросов и получения ответов от процессов файловой системы (FS). Каждая функция строит сообщение запроса в соответствии с запрашиваемыми параметрами, вызывает большинство низкоуровневых fs\_sendrec и копирует обратно конечный ответ -- результат.

Низкоуровневый fs\_sendrec также обеспечивает механизм восстановления при отказе диска и повторяет запрос (не удавшийся в предыдущий раз).

\textbf{select.h} -- Содержит только макроопределения SEL\_OK, EL\_ERROR, SEL\_DEFERRED.

\textbf{select.c} -- Содержит точки входа, связанные с системным вызовом SELECT:
\begin{itemize}
\item do\_select -- выполняет системный вызов SELECT;
\item select\_callback -- сообщает системе SELECT о возможной операции с файловым дескриптором;
\item select\_notified -- низкоуровневый вход для устройств сообщающих в контексте  SELECT;
\item select\_unsuspend\_by\_endpt -- отменяет блокировки при завершении процесса-драйвера.
\end{itemize}

\textbf{stadir.c} -- Этот файл содержит код для выполнения 4-х системных вызовов, связанных с состоянием (do\_chdir do\_chroot do\_stat do\_fstat) и каталогами (файловой системы).

\textbf{table.c} -- Этот файл содержит таблицы, позволяющие отображать номера системных вызовов на процедуры, их обеспечивающие.

\textbf{time.c} -- Этот файл заботится о системных вызовах, которые связаны со временем (создания, доступа, изменения файловых объектов).

\textbf{timers.c} -- Библиотека таймеров файловой системы (FS).

\textbf{utility.c} -- тот файл содержит некоторые процедуры-утилиты общего назначения.

Точки входа:
\begin{itemize}
\item clock\_time -- запрашивает процесс CLOCK о реальном времени, copy: копирует блок данных,
\item fetch\_name -- получает имя пути из пространства пользователя (связано с сокращениями для домашнего каталога,
\item no\_sys -- отвергает системный вызов, который файловая система не обеспечивает;
\item panic -- выполняется тогда, когда происходит событие, исключающее возможность дальнейшего исполнения Minix;
\end{itemize}

\textbf{vnode.h} -- Описывает структуру ноды

\begin{Verbatim}[frame=single]
EXTERN struct vnode

/* indicates absence of vnode slot */
define NIL_VNODE (struct vnode *) 0

/* Field values. */
#define NO_PIPE	0	/* i_pipe is NO_PIPE if inode is not a pipe */
#define I_PIPE	1   /* i_pipe is I_PIPE if inode is a pipe */
\end{Verbatim}

\subsection{Межпроцессное взаимодействие /servers/ipc}

Межпроцессное взаимодействие (англ. inter-process communication, IPC) — обмен данными между потоками одного или разных процессов. Реализуется посредством механизмов, предоставляемых ядром ОС или процессом, использующим механизмы ОС и реализующим новые возможности IPC. Может осуществляться как на одном компьютере, так и между несколькими компьютерами сети.

\textbf{inc.h} -- Содержит стандартные константы и включения для подобного типа подсистем (привилегированных процессов), а также определения внутренних констант и прототипов функций.

Данный сервер является относительно новым (включён только в Minix3.1.5) и мал по объёму. Поэтому данный файл выполняет функции сразу нескольких файлов более объёмных подсистем.

\textbf{sem.c} -- Содержит функции (связанные с семафорами) в.т.ч.:
\begin{Verbatim}[frame=single]
int do_semget(message *m);
int do_semctl(message *m);
int do_semop(message *m);
int is_sem_nil(void);
\end{Verbatim}

\textbf{shm.c} -- Максимальное число областей разделяемой памяти:
\begin{Verbatim}[frame=single]
#define MAX_SHM_NR 1024
\end{Verbatim}

Содержит функции (связанные с разделяемой памятью) в.т.ч.:
\begin{Verbatim}[frame=single]
int do_shmget(message *m);
int do_shmat(message *m);
void update_refcount_and_destroy(void);
int do_shmdt(message *m);
int do_shmctl(message *m);
void list_shm_ds(void);
int is_shm_nil(void);
\end{Verbatim}

\textbf{utility.c}
Содержит только функцию
\begin{Verbatim}[frame=single]
int check_perm(struct ipc_perm *req, endpoint_t who, int mode);
\end{Verbatim}

\subsection{Управление процессами /servers/pm}

Важнейшей частью операционной системы, непосредственно влияющей на функционирование вычислительной машины, является подсистема управления процессами (process management). Процесс (или по-другому, задача) - абстракция, описывающая выполняющуюся программу. Для операционной системы процесс представляет собой единицу работы, заявку на потребление системных ресурсов. Подсистема управления процессами планирует выполнение процессов, то есть распределяет процессорное время между несколькими одновременно существующими в системе процессами, а также занимается созданием и уничтожением процессов, обеспечивает процессы необходимыми системными ресурсами, поддерживает взаимодействие между процессами.

\textbf{alarm.c} -- Этот файл обеспечивает системные вызовы, связанные с отложенными процессами (системным будильником), периодически посылая работу функциям в файле timer.c и check\_sig() в файле signal.c, для посылки сигнала пробуждения процессу.

Точки входа:
\begin{itemize}
\item do\_itimer -- выполняет системный вызов ITIMER;
\item do\_alarm -- выполняет системный вызов ALARM;
\item set\_alarm -- сообщает интерфейсу таймера, чтобы запустить или остановить таймер процесса;
\item check\_vtimer -- проверяет необходимость перезапуска виртуальных таймеров.
\end{itemize}

\textbf{break.c} -- Содержит функцию int do\_brk(). Это точка входа для системного вызова brk(addr).

\textbf{const.h} -- Константы, используемые сервером управления процессами (PM): NR\_PIDS, PM\_PID, INIT\_PID, NO\_TRACER, DUMPED, MAX\_SECS, NR\_ITIMERS.

\textbf{exec.c} -- Этот файл обеспечивает системный вызов EXEC.

Порядок выполняемой работы:
\begin{itemize}
\item проверяет, что файл может быть исполнен (по разрешениям UNIX);
\item читает заголовок и получает размеры;
\item получает начальные аргументы и переменные окружения из пространства пользователя;
\item выделяет память для нового процесса;
\item копирует начальный стек из PM в процесс;
\item читает сегменты кода и данных и копирует в процесс;
\item контролирует биты setuid, setgid;
\item исправляет (изменяет) таблицу «mproc»;
\item сообщает микроядру о EXEC;
\item сохраняет смещение для начального argc (для PS).
\end{itemize}

Точки входа этого файла:
\begin{itemize}
\item do\_exec -- выполняет системный вызов EXEC;
\item exec\_newmem -- выделяет новую карту памяти для процесса, который пытается выполнить EXEC;
\item do\_execrestart -- заканчивает специальный вызов exec для сервера реинкарнации (RS);
\item exec\_restart -- заканчивает обычный вызов exec;
\item find\_share -- находит процесс, сегмент кода которого может быть совместно использовать.
\end{itemize}

\textbf{forkexit.c} -- Этот файл обеспечивает создание процесса (через системный вызов FORK) и уничтожение (стирание) процесса (через EXIT/WAIT).

Когда процесс раздваивается (forks), для него (точнее - процесса-потомка) выделяется новый слот в таблице mproc, а также копия образа родительского процесса. Затем информируется ядро и файловая система.

Процесс удаляется из таблицы «mproc» когда происходят два события:
\begin{enumerate}
\item процесс завершил исполнение или был убит посредством сигнала
\item процесс-родитель выполнил WAIT.
\end{enumerate}

Если процесс завершил исполнение прежде чем его родитель вызвал WAIT, то слот продолжает существовать до тех пор, пока процесс родитель не выполнит соответствующий WAIT.

Точки входа:
\begin{itemize}
\item do\_fork -- выполняет системный вызов FORK;
\item do\_fork\_nb -- неблокирующая версия FORK для сервера реинкарнации (RS);
\item do\_exit -- выполняет системный вызов EXIT (посредством вызова exit\_proc());
\item exit\_proc -- собственно и выполняет завершение процесса, а также сообщает файловой системе об этом;
\item exit\_restart -- продолжает завершение процесса после того, как получен ответ от файловой системы (FS);
\item do\_waitpid -- выполняет системные вызовы WAITPID или WAIT;
\item wait\_test -- проверяет, ждёт ли процесс-родитель завершения данного процесса.
\end{itemize}

\textbf{getset.c} -- Этот файл обеспечивает 6 системных вызовов, которые получают и устанавливают значения uid, gid. Он также обеспечивает getpid(), setsid(), и getpgrp().

Содержит функции:
\begin{itemize}
\item int do\_get(); -- обеспечивает системные вызовы GETUID, GETGID, GETPID, GETPGRP.
\item int do\_set(); -- обеспечивает системные вызовы ETUID, SETEUID, SETGID, SETEGID, SETSID (эти вызовы связаны также с VFS).
\end{itemize}

\textbf{glo.h} -- Глобальные переменные сервера (управления процессами). Они реально выделяются в table.o.

\textbf{main.c} -- Этот файл содержит функцию main для сервера управления процессами и некоторые связанные с main процедуры.

Когда MINIX запускается, в самом начале микроядро инициализирует себя свои задания, а затем оно передаёт управление серверам управления процессами (PM) и файловой системы (FS). Оба: PM и FS инициализуют себя настолько, насколько они могут. Сервер управления процессами (PM) запрашивает микроядро для всей свободной памяти и начинает обслуживать запросы.

Точки входа:
\begin{itemize}
\item main -- запускает сервер управления процессами;
\item setreply -- устанавливает ответ, который отсылается процессу, выполняющему системный вызов к серверу управления процессами (PM).
\end{itemize}

\textbf{misc.c} -- Различные системные вызовы:
\begin{itemize}
\item do\_reboot -- уничтожает все процессы, затем перезагружает систему;
\item do\_procstat -- запрашивает статус процесса
\item do\_getsysinfo -- запрашивает копию структуры данных PM;
\item do\_getprocnr -- ищет номер слота процесса
\item do\_getpuid -- по данной конечной точке находит uid/euid процесса;
\item do\_allocmem -- выделяет (процессу) чанк памяти;
\item do\_freemem -- удаляет (из адресного пространства процесса) чанк памяти;
\item do\_getsetpriority -- получает/устанавливает приоритет процесса;
\item do\_svrctl -- контроль управляющего процессами (планировщика).
\end{itemize}

\textbf{mproc.h} -- Эта таблица содержит по одному слоту для каждого процесса. Она содержит всю информацию по управлению процессами для каждого процесса. Кроме всего прочего, она определяет сегменты кода, данных и стека, а также различные флаги.

Микроядро и файловая система также имеют таблицы, индексированные по процессам, которые содержат соответствующие слоты, относящиеся к одному процессу во всех трёх таблицах.

\textbf{pm.h} -- Это основной заголовочный файл сервера управления процессами. Он включает некоторые другие файлы и определяет некоторые важнейшие константы: \_POSIX\_SOURCE, \_MINIX, \_SYSTEM.

\textbf{signal.c} -- Этот файл поддерживает сигналы, которые являются асинхронными событиями. Сигналы могут быть сгенерированы посредством системного вызова KILL, или от клавиатуры (SIGINT) или от часов (SIGALRM). Во всех случаях контроль в дальнейшем передаётся к функции check\_sig() для определения того, какому процессу посылается сигнал. Реально сигнал выполняется (т.е. изменяется состояние соответствующего процесса) посредством функции sig\_proc().

Точки входа:
\begin{itemize}
\item do\_sigaction -- выполняет системный вызов SIGACTION;
\item do\_sigpending -- выполняет системный вызов SIGPENDING;
\item do\_sigprocmask -- выполняет системный вызов SIGPROCMASK;
\item do\_sigreturn -- выполняет системный вызов SIGRETURN;
\item do\_sigsuspend -- выполняет системный вызов SIGSUSPEND;
\item do\_kill -- выполняет системный вызов KILL;
\item do\_pause -- выполняет системный вызов PAUSE;
\item ksig\_pending -- микроядро уведомляется о необработанном сигнале;
\item sig\_proc -- прерывает или завершает сигнализирующий (или сигнализируемый) процесс;
\item check\_sig -- проверяет, какие процессы должны сигнализироваться посредством sig\_proc();
\item check\_pending -- проверяет, может ли необработанный (ранее) сигнал сейчас быть обработан;
\item restart\_sigs -- возобновляет работу с сигналами после вызова сервера (серверов) файловой системы.
\end{itemize}

\textbf{table.c} -- Этот файл содержит таблицу, которая используется для отображения номеров системных вызовов на процедуры, их обрабатывающие.

\textbf{trace.c} -- Этот файл обеспечивает часть сервера управления процессами (PM), ответственную за отладочные функции, использующие системный вызов ptrace. Большинство команд в дальнейшем посылаются в системное задание микроядра (SYSTEM) для завершения.

Доступные отладочные команды:
\begin{itemize}
\item T\_STOP -- останавливают процесс,
\item T\_OK -- включает трассировку родителем этого процесса,
\item T\_GETINS -- возвращает значение из пространства инструкций,
\item T\_GETDATA -- возвращает значение из пространства данных,
\item T\_GETUSER -- возвращает значение из таблицы пользовательского процесса,
\item T\_SETINS -- устанавливает значение в пространстве инструкций,
\item T\_SETDATA -- устанавливает значение в пространстве данных,
\item T\_SETUSER -- устанавливает значение в таблице пользовательского процесса,
\item T\_RESUME -- восстановить исполнение,
\item T\_EXIT -- выход,
\item T\_STEP -- устанавливает бит трассирования,
\item T\_SYSCALL -- системный вызов трассирования,
\item T\_ATTACH -- подключить к существующему процессу,
\item T\_DETACH -- отключить от существующего процесса,
\item T\_SETOPT -- устанавливает опции трассирования.
\end{itemize}

\textbf{utility.c} -- Этот файл содержит некоторые обслуживающие функции сервера управления процессами (PM).

\subsection{Виртуальная память /servers/vm}

Виртуальная память (англ. virtual memory) -- метод управления памятью компьютера, позволяющий выполнять программы, требующие больше оперативной памяти, чем имеется в компьютере, путём автоматического перемещения частей программы между основной памятью и вторичным хранилищем (например, жёстким диском). Для выполняющейся программы данный метод полностью прозрачен и не требует дополнительных усилий со стороны программиста, однако реализация этого метода требует как аппаратной поддержки, так и поддержки со стороны операционной системы.

В системе с виртуальной памятью используемые программами адреса, называемые виртуальными адресами, транслируются в физические адреса в памяти компьютера. Трансляцию виртуальных адресов в физические выполняет аппаратное обеспечение, называемое блоком управления памятью. Для программы основная память выглядит как доступное и непрерывное адресное пространство, либо как набор непрерывных сегментов, вне зависимости от наличия у компьютера соответствующего объёма оперативной памяти. Управление виртуальными адресными пространствами, соотнесение физической и виртуальной памяти, а также перемещение фрагментов памяти между основным и вторичным хранилищами выполняет операционная система.

\textbf{addravl.h} -- Содержит определения констант и макросов препроцессора.

\textbf{addravl.c} -- Содержит только включения заголовков.

\textbf{alloc.c} -- Этот файл связан с выделением и освобождением блоков физической памяти произвольной величины в контексте системных вызовов FORK и EXEC. Ключевая используемая структура данных -- таблица свободных участков, которая поддерживает список свободных участков памяти. Они поддерживаются в порядке возрастания адреса памяти. Эти адреса содержат ссылки на физическую память, начиная с абсолютного адреса 0 (т.е. они не являются относительными от начала (адресного пространства) сервера управления процессами (PM)). Во время инициализации системы, часть памяти, содержащая вектора прерываний, микроядро и сервер управления процессами (PM) размещены в смысле пометки их (областей памяти) как недоступными для выделения и удаления их из списка свободных мест.

Точки входа:
\begin{itemize}
\item alloc\_mem -- выделяет чанк памяти данного размера;
\item free\_mem -- освобождает прежде выделенный чанк памяти;
\item mem\_init -- инициализирует таблицы когда сервер управления процессами запускается.
\end{itemize}

\textbf{break.c} -- Модель выделения памяти MINIX резервирует участки памяти фиксированного размера для комбинированных сегментов кода, данных и стека. Эти размеры используются для процесса-потомка созданного посредством FORK те же, что и для процесса-родителя. Если процесс-потомок позже выполняет EXEC,будут использованы новые размеры из заголовка запускаемого бинарного исполняемого файла.

Расположение памяти состоит из сегмента текста, после которого следует сегмент данных, за которым следует куча (неиспользуемая память), после которой следует сегмент стека. Сегмент данных растёт вверх, а сегмент стека -- вниз, таким образом каждый из них может заимствовать память из кучи. Если они встречаются процесс должен быть уничтожен. Процедуры данного файла заботятся о росте сегментов данных и стека.

Точки входа:
\begin{itemize}
\item do\_brk -- системные вызовы BRK/SBRK для роста или сокращения сегмента данных;
\item adjust -- смотрит разрешено ли запрашиваемое изменение сегментов (в смысле полномочий и привилегий).
\end{itemize}

\textbf{exec.c} -- Содержит функции:
\begin{Verbatim}[frame=single]
struct vmproc *find_share(vmp_ign, ino, dev, ctime);
\end{Verbatim}
Ищет процесс, который исполняет файл <ino, dev, ctime>.
Не обязательно найдёт vmp\_ign, так как это процесс, от лица которого этот вызов выполняется.

\begin{Verbatim}[frame=single]
int do_exec_newmem(message *msg);
int new_mem(rmp, sh_mp, text_bytes, data_bytes, bss_bytes, stk_bytes, tot_bytes, stack_top);
\end{Verbatim}
Выделяет новую память и освобождает старую память.
Изменяет карту памяти и сообщает новую микроядру. Обнуляет bss, «кучу» и стек нового образа (памяти).

\begin{Verbatim}[frame=single]
phys_bytes find_kernel_top(void);
\end{Verbatim}
Определяет где находится микроядро, чтобы таким образом знать начало отображения пользовательских процессов.

\begin{Verbatim}[frame=single]
int proc_new(struct vmproc *vmp,
phys_bytes vstart,	/* где начать процесс в таблице страниц*/ phys_bytes text_bytes, /* как много кода, в байтах но выравненного по страницам*/
phys_bytes data_bytes, /* как много данных + bss, в байтах но ...*/ phys_bytes stack_bytes, /* резервируемый размер стека, в байтах но ... */
phys_bytes gap_bytes,   /* «куча» , в байтах но ...*/
phys_bytes text_start, /* код начинается здесь, если предварительно выделен, иначе 0 */
phys_bytes data_start, /*участок данных начинается здесь, если предварительно выделен, иначе 0 */
phys_bytes stacktop
);
\end{Verbatim}

\textbf{exit.c} -- Содержит функции:
\begin{Verbatim}[frame=single]
void free_proc(struct vmproc *vmp);
void clear_proc(struct vmproc *vmp);
int do_exit(message *msg);
int do_willexit(message *msg);
void _exit(int code);
void exit(int code);
\end{Verbatim}

\textbf{fork.c} -- Содержит функцию:
\begin{Verbatim}[frame=single]
int do_fork(message *msg);
\end{Verbatim}

\textbf{physravl.h} -- Определяет константы и макросы.

\textbf{physravl.c} -- Состоит только из включений заголовочных файлов.

\textbf{proto.h} -- Содержит прототипы функций сгруппированные по файлам.

\textbf{slaballoc.c} -- Содержит огромное множество определений макросов

\textbf{util.h} -- Содержит определения макросов

\textbf{utility.c} -- Этот файл содержит некоторые служебные функции для сервера виртуальной памяти (VM):
\begin{Verbatim}[frame=single]
int get_mem_map(proc_nr, mem_map);
void get_mem_chunks(mem_chunks);
\end{Verbatim}
Инициализирует свободную память.
Переводит байтовые сдвиги и размеры в этом списке в клики, нарезанные правильным образом.
\begin{Verbatim}[frame=single]
void reserve_proc_mem(mem_chunks, map_ptr);
\end{Verbatim}
Выбирает память сервера из списка свободной памяти. Монитор загрузки обещает поместить процессы в начале чанков памяти. Все задания (микроядра) используют одинаковый базовый адрес, таким образом только первое задание изменяет списки памяти. Серверы и init имеют свои собственные пространства памяти и их память в дальнейшем будет удалена из этого списка (свободной памяти).
\begin{Verbatim}[frame=single]
int vm_isokendpt(endpoint_t endpoint, int *proc);
int get_stack_ptr(proc_nr_e, sp);
int brk(brk_addr);
int do_ctl(message *m);
\end{Verbatim}

\textbf{vm.h} -- Определяет некоторые общие константы и макросы.


