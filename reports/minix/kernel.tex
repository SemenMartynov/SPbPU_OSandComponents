\newpage
\section{Микроядро}

\subsection{Директория /kernel}

Директория /kernel содержит следующие файлы:

\textbf{clock.c (12K)} -- Содержит функции для инициализации таймера и обработчиков таймера. Содержит как обработчик аппаратного прерывания, так и бесконечный цикл для обработки событий. Важные события, обрабатываемые посредством CLOCK, включают также решения по планированию и перепланированию процессов. CLOCK предлагает непосредственный интерфейс с процессами микроядра. Системные службы могут обращаться (к данному файлу) посредством системных вызовов, таких как sys\_setalarm().

При видоизменении данного файла нельзя использовать send() если получатель не готов принять сообщение. Вместо этого желательно использовать notify().

CLOCK -- это один из процессов микроядра, не вынесенный в отдельный сервер по соображениям производительности.

\textbf{clock.h (4,0K)} -- Определяет функции для инициализации таймера и обработчиков таймера.

\textbf{config.h (4,0K)} -- Определяет конфигурацию микроядра. Позволяет установить размеры буферов ядра, включить или исключить отладочный код, функции контроля времени и отдельные вызовы микроядра. (поэтому здесь содержаться краткие их описания, тем не менее настоятельно рекомендуется сохранять все вызовы микроядра включёнными).

Этот файл по логике должен быть одним из основных координирующих файлов, однако похоже, что эта функция уже давно стала атавизмом...

\textbf{const.h (4,0K)} -- Содержит макросы и константы, используемые в коде микроядра. В частности, содержит макросы для запрещения и разрешения аппаратных прерываний.

Общие определения и макросы помещаются в этом файле.

\textbf{debug.c (12K)} -- Этот файл содержит отладочные функции, не включённые в стандартное микроядро. Доступные функции включают отсчёт времени для блокировок и проверочные функции для очередей управления.

\textbf{debug.h (4,0K)} -- Определяет все отладочные константы и макросы,а также некоторые (глобальные) переменные. Некоторые отладочные функции требуют переопределения стандартных констант и макросов, поэтому данный заголовочный файл должен находится ПОСЛЕ остальных заголовочных файлов микроядра.

\textbf{glo.h (4,0K)} -- Определяет используемые в микроядре глобальные переменные (сами переменные размещаются в table.o). На данный момент определяет:
\begin{itemize}
\item переменные режима ядра (исключение, выход из системы);
\item переменные-структуры информации о ядре;
\item диагностические сообщения;
\item генератора случайных чисел, средней загрузке;
\item указатель на текущий выполняющийся процесс;
\item указатель на следующий процесс, после restart();
\item указатель на процесс для подсчёта тиков;
\item указатель на первые процессы в очередях restart, request, pagefault;
\item переменную учёта тиков, не учтённых в задании CLOCK.
\end{itemize}

\textbf{interrupt.c (8,0K)} -- Система аппаратных прерываний Minix3. Содержит процедуры для
управления контроллером прерываний:
\begin{itemize}
\item регистрации/удаления обработчика прерываний (PUBLIC void irq\_handle(int irq) вызывается системно зависимой частью при возникновении внешнего прерывания);
\item разрешения/запрещения линии прерываний.
\end{itemize}
Определяет переменную:
\begin{Verbatim}[frame=single]
PUBLIC irq_hook_t* irq_handlers[NR_IRQ_VECTORS] = {0};
\end{Verbatim}

\textbf{interrupt.h (4,0K)} -- Прототипы для системы аппаратных прерываний.

\textbf{ipc.h (4,0K)} -- Этот файл определяет константы для межпроцессного взаимодействия. Определения используются в /kernel/proc.c. Пока это константы NON\_BLOCKING, SEND, RECEIVE, SENDREC,
NOTIFY, SENDNB, SENDA а также макрос WILLRECEIVE(target, source\_ep).

\textbf{kernel.h (4,0K)} -- Основной заголовочный файл микроядра Minix3. Однако сам по себе он состоит только из заголовков. В частности, он включает почти все заголовочные файлы из /kernel/ .

\textbf{main.c (16K)} -- Описывает начальный старт микроядра (оно находится ещё в загрузочном образе и уже имеет набор готовых к исполнению системных процессов -- серверов).

\textbf{priv.h (4,0K)} -- Определяет структуру системы привилегий struct priv. Каждый системный процесс имеет собственную структуру привилегий, для всех пользовательских процессов используется одна
структура привилегий:

\begin{Verbatim}[frame=single]
#define USER_PRIV_ID 0
\end{Verbatim}

\textbf{proc.c (60K)} -- Вместе с mpx.s этот файл содержит наиболее низкоуровневую часть микроядра. 

Содержит точку входа для внешних вызовов: sys\_call -- системный вызов, когда мы попадаем в микроядро посредством INT. Имеется также несколько точек входа для прерываний и уровня заданий: lock\_send -- послать сообщение процессу.

Этот файл очень большой и требует дополнительного рассмотрения низкоуровневых функций.

Следует только заметить, что PROC является одним из процессов микроядра не вынесенным в отдельный сервер по соображениям производительности.

\textbf{proc.h (12K)} -- Определяет таблицу процессов. Таблица процессов включает
\begin{itemize}
\item состояние регистров и флагов,
\item приоритет планировщика,
\item таблица памяти,
\item различные учётные данные,
\item информацию, используемую для передачи сообщений (IPC).
\end{itemize}

Многие ассемблерные процедуры обращаются к полям этой структуры. Смещения определены в ассемблерном включаемом файле kernel/arch/i386/sconst.h. Эти два файла должны соответствовать друг другу!

Кроме того определены флаги исполнения (runtime) и макросы, для их проверки, установки, очистки.
\begin{Verbatim}[frame=single]
EXTERN struct proc proc[NR_TASKS + NR_PROCS]; /* process table */
EXTERN struct proc *rdy_head[NR_SCHED_QUEUES]; /* ptrs to ready list headers */
EXTERN struct proc *rdy_tail[NR_SCHED_QUEUES]; /* ptrs to ready list tails */
\end{Verbatim}

\textbf{profile.c (8,0K)} -- Этот файл содержит несколько функций и переменных, используемых для системного профилирования: статистическое профилирование (обработчик прерываний для часов профилирования) и профилирование вызовов (таблица, используемая для данных профилирования, а также
функция для определения её размеров; функция используется процессами микроядра для регистрации их управляющих структур и таблицы профилирования).

\textbf{profile.h (4,0K)} -- Определяет переменные для профилирования. Зависит от /include/minix/profile.h
Содержит общую опцию
\begin{Verbatim}[frame=single]
#if SPROFILE /* statistical profiling */
\end{Verbatim}

\textbf{proto.h (8,0K)} -- Файл содержит все прототипы функций (публичного интерфейса), определённых в файлах clock.c, main.c, utility.c, proc.c, start.c, system.c, system/do\_newmap.c, system/do\_vtimer.c, interrupt.c, debug.c, system/do\_safecopy.c, system/do\_sysctl.c, profile.c директории /kernel, включая части, зависящие от конкретной платформы.

\textbf{smp.c (8,0K)} -- архитектурно-зависимая реализация режима мультипроцессорности.

\textbf{smp.h (4,0K)} -- заголовок для симметричной мультипроцессорности.

\textbf{spinlock.h (4,0K)}

\textbf{system.c (24,0K)} -- Обеспечивает интерфейс между микроядром и серверами системных вызовов. Для отображения системных вызовов на функции, их обеспечивающие применяется внутренний вектор вызовов. Сами эти функции находятся в отдельных файлах (/kernel/system/). Вектор вызовов используется в основном цикле системного задания для обработки входящих запросов.

Кроме основной точки входа (sys\_task()), в котором и запускается основной цикл, имеется ещё несколько точек входа:
\begin{itemize}
\item get\_priv -- заполняет структуру привилегий для пользовательского или системного процесса,
\item set\_sendto\_bit -- позволяет процессу послать сообщение в новом направлении (расширяет привилегии),
\item unset\_sendto\_bit -- запрещает процессу послать сообщение в новом направлении (сужает привилегии),
\item send\_sig -- посылает сигнал прямо системному процессу,
\item cause\_sig -- выполняет действие вызванное сигналом вызывая событие через сервер управления процессами,
\item sig\_delay\_done -- сообщает серверу управления процессами что процесс не посылает,
\item umap\_bios -- отображает виртуальный адрес в BIOS\_SEG на физический,
\item get\_randomness -- накапливает случайности в буфер,
\item clear\_endpoint -- лишает процесс возможности посылать и принимать сообщения.
\end{itemize}

SYS является одним из заданий микроядра.

\textbf{system.h (8,0K)} -- Прототипы функций системной библиотеки. Сами функции находятся в /kernel/system/. Если вызов микроядра не включён посредством конфигурации /kernel/config.h, то функция становится синонимом do\_unused().

Системная библиотека делает доступным системный сервис посредством вызовов микроядра. Системные вызовы трансформируются в сообщения-запросы к заданию SYS, способному выполнить соответствующий
вызов.

По соглашению sys\_call() преобразуется в сообщение с типом SYS\_CALL, которое обрабатывается функцией do\_call().

\textbf{table.c (4,0K)} -- Содержит большинство данных микроядра. Непосредственно в данном файле определены
\begin{itemize}
\item константы препроцессора:
\begin{itemize}
\item для размеров стеков заданий микроядра,
\item флаги для различных типов процессов (микроядра),
\item списки FS\_C и DRV\_C (разрешённых высовов микроядра),
\end{itemize}
\item макросы препроцессора:
\begin{itemize}
\item для определения масок системных вызовов для различных типов процессов,
\end{itemize}
\item глобальные переменные:
\begin{itemize}
\item fs\_c[], pm\_c[], rs\_c[], ds\_c[], vm\_c[], drv\_c[], usr\_c[], tty\_c[], mem\_c[],
\item PUBLIC struct boot\_image image[]
\end{itemize}
\end{itemize}

EXTERN внутри данного файла принимает значение пустой строки, поэтому глобальные переменные определённые в заголовочных файлах реально привязываются к данному файлу (место им выделяется в table.o).

\textbf{type.h (4,0K)} -- Определяет типы, связанные с таблицей процессов и другими свойствами (переменными) системы (микроядра): task\_t, proc\_nr\_t, sys\_id\_t, sys\_map\_t, struct boot\_image, irq\_policy\_t, irq\_id\_t, struct irq\_hook, irq\_hook\_t, irq\_handler\_t.

\textbf{usermapped\_data.c (4,0K)}

\textbf{utility.c (4,0K)} -- Этот файл содержит коллекцию различных процедур:
\begin{itemize}
\item minix\_panic -- прерывает MINIX в связи с фатальной ошибкой,
\item kputc -- буферизированный putc, используемый функцией kprintf,
\item kprintf -- посредством включения файла lib/sysutil/kprintf.c и замены printf на kprintf посредством препроцессора.
\end{itemize}

\textbf{vm.h (4,0K)} -- Содержит константы препроцессора: VMSUSPEND, EFAULT\_SRC, EFAULT\_DST и макросы: FIXLINMSG(prp), PHYS\_COPY\_CATCH(src, dst, size, a).

Файл связан с механизмами виртуальной памяти.

\textbf{watchdog.c (4,0K)} -- реализация архитектурно-зависимого механизма watchdog, используемого для выявления ошибок в ядре

\textbf{watchdog.h (4,0K)} -- прототип механизма watchdog

\subsection{Директория /kernel/system}

\textbf{do\_abort.c (4,0K)} -- Реализуется вызов микроядра SYS\_ABORT (прерывание работы OS Minix3)

Параметры:
\begin{itemize}
\item ABRT\_HOW -- как выполнить прерывание работы OS Minix3)
\item ABRT\_MON\_ENDPT -- номер процесса параметры монитора которого берутся
\item ABRT\_MON\_LEN -- длина параметров монитора
\item ABRT\_MON\_ADDR -- виртуальный адрес параметров
\end{itemize}

\textbf{do\_copy.c (4,0K)} -- Реализуется вызовы микроядра SYS\_VIRCOPY (копирование областей виртуальной памяти), SYS\_PHYSCOPY (копирование областей физической памяти).

Параметры:
\begin{itemize}
\item CP\_SRC\_SPACE -- виртуальный сегмент копируемых данных
\item CP\_SRC\_ADDR -- смещение копируемых данных относительно сегмента
\item CP\_SRC\_PROC\_NR -- номер процесса из виртуальной памяти которого происходит копирование
\item CP\_DST\_SPACE -- виртуальный сегмент, куда копируются данные
\item CP\_DST\_ADDR -- смещение относительно виртуального сегмента, куда копируются данные
\item CP\_DST\_PROC\_NR -- номер процесса, в виртуальное адресное пространство которого копируются данные
\item CP\_NR\_BYTES -- размер копируемых данных в байтах
\end{itemize}

\textbf{do\_cprofile.c (8,0K)} -- Реализуется вызов микроядра SYS\_CPROFILE (профилирование вызовов).

Параметры:
\begin{itemize}
\item PROF\_ACTION -- получить/сбросить данные профилирования
\item PROF\_MEM\_SIZE -- доступная память для данных
\item PROF\_ENDPT -- узловая точка вызывающего
\item PROF\_CTL\_PTR -- расположение информационной структуры
\item PROF\_MEM\_PTR -- местоположение памяти для данных
\end{itemize}

\textbf{do\_devio.c (4,0K)} -- Реализуется вызов микроядра SYS\_DEVIO (Осуществляет низкоуровневый ввод/вывод в порты ввода/вывода)

Параметры:
\begin{itemize}
\item DIO\_REQUEST -- запрос на ввод или вывод
\item DIO\_PORT -- порт для ввода/вывода
\item DIO\_VALUE -- возвращает прочтённое значение
\end{itemize}

\textbf{do\_mapdma.c (4,0K)} -- Реализуется вызов микроядра SYS\_MAPDMA (Выделяет область для выполнения операции устройства с непосредственным доступом к памяти.)

Параметры:
\begin{itemize}
\item CP\_SRC\_ADDR -- Виртуальный адрес.
\item CP\_NR\_BYTES -- Размер структуры данных.
\end{itemize}

\textbf{do\_endksig.c (4,0K)} -- Реализуется вызов микроядра SYS\_ENDKSIG (Вызывается сервером управления процессами (PM) после обработки сигнала процессу SYS\_GETKSIG. Обычно это сигнал прерывания процесса.)

Параметры:
\begin{itemize}
\item SIG\_ENDPT -- Процесс, для которого выполнено задание сервера управления процессами (PM)
\end{itemize}

\textbf{do\_exec.c (4,0K)} -- Реализуется вызов микроядра SYS\_EXEC (Замена контекста процесса.)

Параметры:
\begin{itemize}
\item PR\_ENDPT -- Процесс, вызвавший exec
\item PR\_STACK\_PTR -- Новый указатель на стек
\item PR\_NAME\_PTR -- Указатель на имя программы
\item PR\_IP\_PTR -- Новый указатель инструкций
\end{itemize}

\textbf{do\_exit.c (4,0K)} -- Реализуется вызов микроядра SYS\_EXIT (Завершает процесс.)

Параметры:
\begin{itemize}
\item PR\_ENDPT -- Номер слота завершающегося процесса.
\end{itemize}

\textbf{do\_fork.c (8,0K)} -- Реализуется вызов микроядра SYS\_FORK (Создание нового процесса -- копии родительского.)

Параметры:
\begin{itemize}
\item PR\_ENDPT -- Родитель, процесс, который разветвляется
\item PR\_SLOT -- Слот порождаемого процесса-ребёнка в таблице процессов.
\item PR\_MEM\_PTR -- Новая карта памяти для процесса-ребёнка.
\item PR\_FORK\_FLAGS -- Флаги-параметры вызова fork.
\end{itemize}

\textbf{do\_getinfo.c (8,0K)} -- Реализуется вызов микроядра SYS\_GETINFO (Запрос на системную информацию, которая копируется в адресное пространство запрашивающего процесса. Этот вызов просто копирует соответствующие структуры данных запрашивающему процессу.)

Параметры:
\begin{itemize}
\item I\_REQUEST -- Какую информацию?
\item I\_VAL\_PTR -- Куда её поместить?
\item I\_VAL\_LEN -- Максимальная возможная длина
\item I\_VAL\_PTR2 -- Второй параметр (может не быть)
\item I\_VAL\_LEN2\_E -- Вторая длина или номер процесса.
\end{itemize}

\textbf{do\_getksig.c (4,0K)} -- Реализуется вызов микроядра: SYS\_GETKSIG (Сервер управления процессами (PM) готов обрабатывать сигналы и периодически делает вызов микроядра для получения очередного сигнала.)

Параметры:
\begin{itemize}
\item SIG\_ENDPT -- Процесс, посылающий сигнал
\item SIG\_MAP -- Набор битов сигнала
\end{itemize}

\textbf{do\_irqctl.c (8,0K)} -- Реализуется вызов микроядра SYS\_IRQCTL (Позволяет , в частности, вставить новый обработчик прерываний. Возвращает индекс ловушки прерывания, назначенный в микроядре.)

Параметры:
\begin{itemize}
\item IRQ\_REQUEST -- Контрольная операция, которую надо выполнить.
\item IRQ\_VECTOR -- Линия прерываний, которая должна быть проверена.
\item IRQ\_POLICY -- Позволяет вновь разрешить прерывания.
\item IRQ\_HOOK\_ID -- Предоставляет индекс, который будет возвращён при прерывании.
\end{itemize}

\textbf{do\_kill.c (4,0K)} -- Реализуется вызов микроядра SYS\_KILL (Обеспечивает sys\_kill(). Вызывает посылку сигнала процессу. Сервер управления процессами (PM) – центральный сервер, где обрабатываются все сигналы и обеспечиваются регистрация порядка их обработки. Любой запрос, за исключением запросов сервера управления процессами (PM), добавляется в "карту" необработанных сигналов, а сервер управления процессами (PM) информируется о поступлении нового сигнала. Так как системные серверы не могут использовать нормальные POSIX сигналы (ввиду того, что они обычно блокируют процесс на их получении), они могут запросить сервер управления
процессами (PM) преобразовать сигналы в сообщения. Это выполняется сервером управления процессами (PM) посредством вызова sys\_kill().)

Параметры:
\begin{itemize}
\item SIG\_ENDPT -- процесс, которому посылается сигнал/ необработанный
\item SIG\_NUMBER -- Номер сигнала, который посылается процессу.
\end{itemize}

\textbf{do\_mcontext.c (4,0K)}

\textbf{do\_memset.c (4,0K)} -- Реализуется вызов микроядра SYS\_MEMSET (Записывает образец в определённый участок памяти.)

Параметры:
\begin{itemize}
\item MEM\_PTR -- виртуальный адрес
\item MEM\_COUNT -- возвращает физический адрес
\item MEM\_PATTERN -- байт-образец, которым заполняется область
\end{itemize}

\textbf{do\_privctl.c (12K)} -- Реализуется вызов микроядра SYS\_PRIVCTL (Обновляет привилегии процесса. Если процесс пока не является системным процессом, выделяет ему его собственную структуру привилегий.)

Параметры:
\begin{itemize}
\item CTL\_ENDPT -- Точка окончания целевого процесса.
\item CTL\_REQUEST -- Запрос контроля привилегий.
\item CTL\_ARG\_PTR -- Указатель на запрашиваемые данные.
\end{itemize}

\textbf{do\_profbuf.c (4,0K)} -- Реализуется вызов микроядра SYS\_PROFBUF (При помощи данного вызова микроядра профилируемые процессы и информируют микроядро о местоположении их таблицы профилирования и контрольной структуры. Вызов микроядра используется системой профилирования когда установлена опция профилирования вызовов.)

Параметры:
\begin{itemize}
\item PROF\_CTL\_PTR -- Местоположение контрольной структуры.
\item PROF\_MEM\_PTR -- Местоположение таблицы профилирования.
\end{itemize}

\textbf{do\_runctl.c (4,0K)} -- Реализуется вызов микроядра SYS\_RUNCTL Контролирует флаги PROC\_STOP процесса. Используется для управления процессами. В некоторых случаях устанавливает MF\_SIG\_DELAY вместо PROC\_STOP. Используется сервером управления процессами (PM) для надёжности управления сигналами.)

Параметры
\begin{itemize}
\item RC\_ENDPT -- Номер контролируемого процесса.
\item RC\_ACTION -- Останавливает или восстанавливает исполнение процесса.
\item RC\_FLAGS -- Флаги запроса.
\end{itemize}

\textbf{do\_safecopy.c (12K)} -- Реализуется вызовы микроядра SYS\_SAFECOPYFROM, SYS\_SAFECOPYTO, SYS\_VSAFECOPY (Безопасное копирование. Копирование областей памяти с контролем разрешений.)

Параметры:
\begin{itemize}
\item SCP\_FROM\_TO -- другая точка окончания
\item SCP\_INFO -- находящийся в собственности вызывающего процесса сегмент из/в который происходит копирование.
\item SCP\_GID -- Идентификатор разрешения
\item SCP\_OFFSET -- Смещение внутри разрешённой области.
\item SCP\_ADDRESS -- Адрес в собственном адресном пространстве.
\item SCP\_BYTES -- Размер копируемой области в байтах.
\end{itemize}

\textbf{do\_nice.c (4,0K)} -- Реализуется вызов микроядра SYS\_NICE (Изменяет приоритет процесса или прекращает выполнение процесса.)

Параметры:
\begin{itemize}
\item PR\_ENDPT -- Номер процесса, приоритет которого изменяется.
\item PR\_PRIORITY -- Новый приоритет.
\end{itemize}

\textbf{do\_segctl.c (4,0K)} -- Реализуется вызов микроядра SYS\_SEGCTL (Возвращает переключатель сегмента и смещение, которые могут быть использованы для достижения физических адресов, для использования в драйверах выполняющих отображённый на память ввод/вывод в области A0000 – DFFFF.)

Параметры:
\begin{itemize}
\item SEG\_PHYS -- Базовый физический адрес.
\item SEG\_SIZE -- Размер сегмента.
\item SEG\_SELECT -- Возвращает переключатель сегмента.
\item SEG\_OFFSET -- Возвращает смещение внутри сегмента.
\item SEG\_INDEX -- Возвращает индекс опосредованной памяти.
\end{itemize}

\textbf{do\_sysctl.c (4,0K)} -- Реализуется вызов микроядра SYS\_SYSCTL.

Параметры:
\begin{itemize}
\item SYSCTL\_CODE -- Запрос.
\item SYSCTL\_ARG1 -- Специфические для запроса аргументы.
\item SYSCTL\_ARG2 -- Специфические для запроса аргументы.
\end{itemize}

\textbf{do\_setalarm.c (4,0K)} -- Реализуется вызов микроядра SYS\_SETALARM (Выполняет запрос на синхронный сигнал, или на отмену синхронного сигнала.)

Параметры:
\begin{itemize}
\item ALRM\_EXP\_TIME -- Время до подачи сигнала.
\item ALRM\_ABS\_TIME -- Абсолютное время до подачи сигнала.
\item ALRM\_TIME\_LEFT -- Возвращает секунды, прошедшие от предыдущего сигнала.
\end{itemize}

\textbf{do\_setgrant.c (4,0K)} -- Реализуется вызов микроядра SYS\_SETGRANT (Устанавливает разрешения.)

Параметры:
\begin{itemize}
\item SG\_ADDR -- Адрес таблицы разрешений в собственном адресном пространстве.
\item SG\_SIZE  -- Число записей таблицы
\end{itemize}

\textbf{do\_sigreturn.c (4,0K)} -- Реализуется вызов микроядра SYS\_SIGRETURN (Запрос в стиле сигналов POSIX. Требует, чтобы sys\_sigreturn упорядочил всё прежде, чем сигнализирующий процесс мог снова выполняться.)

Параметры:
\begin{itemize}
\item SIG\_ENDPT -- Процесс, возвращающийся из обработки
\item SIG\_CTXT\_PTR -- Указатель на структуру контекстов сигналов
\end{itemize}

\textbf{do\_sigsend.c (8,0K)} -- Реализуется вызов микроядра SYS\_SIGSEND (Обеспечение сигналов в стиле POSIX.)

Параметры:
\begin{itemize}
\item SIG\_ENDPT -- Процесс для вызова обеспечения сигнала
\item SIG\_CTXT\_PTR -- Указатель на структуру контекста сигналов
\item SIG\_FLAGS -- Флаги для вызова S\_SIGRETURN.
\end{itemize}

\textbf{do\_sprofile.c (4,0K)} -- Реализуется вызов микроядра SYS\_SPROFILE (Обеспечивает статистическое профилирование.)

Параметры:
\begin{itemize}
\item PROF\_ACTION -- Начинает/прекращает профилирование.
\item PROF\_MEM\_SIZE -- Доступная память для данных.
\item PROF\_FREQ -- Частота запрашиваемого образца.
\item PROF\_ENDPT -- Конечная точка запрашивающего.
\item PROF\_CTL\_PTR -- Местоположение информационной структуры.
\item PROF\_MEM\_PTR -- Местоположение памяти для данных.
\end{itemize}

\textbf{do\_stime.c (4,0K)} -- Реализуется вызов микроядра SYS\_STIME (Системное время)

Параметры:
\begin{itemize}
\item T\_BOOTITME -- Время с момента загрузки системы
\end{itemize}

\textbf{do\_times.c (4,0K)} -- Реализуется вызов микроядра SYS\_TIMES (Устанавливает информацию о времени в сообщение. Прерывание часов (таймера) может обновить системное время, что не мешает данному коду.)

Параметры:
\begin{itemize}
\item T\_ENDPT -- Получает информацию для данного процесса.
\end{itemize}

\textbf{do\_trace.c (8,0K)} -- Реализуется вызов микроядра SYS\_TRACE (Обеспечивает отладочную трассировку.)

Параметры:
\begin{itemize}
\item CTL\_ENDPT -- Трассируемый процесс.
\item CTL\_REQUEST -- Запрос трассирования.
\item CTL\_ADDRESS -- Адрес в пространстве трассируемого процесса.
\item CTL\_DATA -- Данные, которые должны быть записаны, или место для возвращаемых данных.
\end{itemize}

\textbf{do\_umap.c (4,0K)} -- Реализуется вызов микроядра SYS\_UMAP (Создаёт карту отображения виртуальных адресов на физические)

Параметры:
\begin{itemize}
\item CP\_SRC\_PROC\_NR -- Номер процесса.
\item CP\_SRC\_SPACE -- Сегмент, где находится адрес: T (код), D (данные), или S (стек).
\item CP\_SRC\_ADDR -- Виртуальный адрес.
\item CP\_DST\_ADDR -- Возвращает физический адрес.
\item CP\_NR\_BYTES -- Размер структуры данных.
\end{itemize}

\textbf{do\_newmap.c (8,0K)} -- Реализуется вызов микроядра SYS\_NEWMAP (Создаёт новую карту памяти)

Параметры:
\begin{itemize}
\item PR\_ENDPT -- устанавливает новую карту памяти для этого процесса
\item PR\_MEM\_PTR -- указатель на новую карту памяти
\end{itemize}

\textbf{do\_vcopy.c (8,0K)} -- Реализуется вызовы микроядра SYS\_VIRVCOPY, SYS\_PHYSVCOPY (Копирования физической/виртуальной памяти.) 

Параметры:
\begin{itemize}
\item VCP\_VEC\_SIZE -- Размер вектора, запрашиваемого на копирование.
\item VCP\_VEC\_ADDR -- Адрес вектора (в адресном пространстве запрашивающего процесса.
\item VCP\_NR\_OK -- Число успешно скопированных байт, или элементов вектора.
\end{itemize}

\textbf{do\_vdevio.c (8,0K)} -- Реализуется вызов микроядра SYS\_VDEVIO (Выполняет серию операций с устройствами ввода/вывода от имени процесса (а не задания микроядра). Адреса ввода/вывода и значения ввода/вывода получаются или возвращаются в некоторый буфер в адресном пространстве процесса. Реальный ввод/вывод обрамлен lock() и unlock(), во избежание прерываний. Является вызовом, родственным do\_devio, выполняющим одиночную операцию с устройством ввода/вывода.)

Параметры:
\begin{itemize}
\item DIO\_REQUEST -- Запрос на ввод или вывод.
\item DIO\_VEC\_ADDR -- Указатель на пару порт/значение.
\item DIO\_VEC\_SIZE -- Число портов для ввода/вывода.
\end{itemize}

\textbf{do\_vmctl.c (8,0K)} -- Реализуется вызов микроядра SYS\_VMCTL (Обеспечивает нужды виртуальной памяти)

Параметры:
\begin{itemize}
\item SVMCTL\_WHO -- Какой процесс?
\item SVMCTL\_PARAM -- Устанавливает имя параметра
\item SVMCTL\_VALUE -- Устанавливает значение параметра
\end{itemize}

\textbf{do\_vtimer.c (4,0K)} -- Реализуется вызов микроядра SYS\_VTIMER

Параметры:
\begin{itemize}
\item VT\_WHICH -- Таймер: VT\_VIRTUAL или VT\_PROF
\item VT\_SET -- Установить или просто получить?
\item VT\_VALUE -- Новое/старое время достижения в тиках.
\item VT\_ENDPT -- Процесс, которому принадлежит таймер.
\end{itemize}

\subsection{Директория /kernel/arch/i386/include}

\textbf{archconst.h (8,0K)} -- Содержит константы для защищённого режима процессора i386.

\textbf{archtypes.h (4,0K)} -- Определяет типы и структуры для регистров процессора, сегментного дескриптора защищённого режима процессора, страничных исключений


\subsection{Директория /kernel/arch/i386}

\textbf{arch\_do\_vmctl.c (4,0K)} -- Реализуется вызов микроядра SYS\_VMCTL (Обеспечивает нужды виртуальной памяти. Архитектурно зависимая часть.)

Параметры:
\begin{itemize}
\item SVMCTL\_WHO -- Какой процесс?
\item SVMCTL\_PARAM -- Устанавливает имя параметра
\item SVMCTL\_VALUE -- Устанавливает значение параметра
\end{itemize}

\textbf{clock.h (4.0K)} -- Прототипы функций инициализации, сброса и чтения значения счётчика системного таймера 8253A. Архитектурно зависимая часть.

\textbf{clock.c (4.0K)} -- Реализует функции:

\begin{Verbatim}[frame=single]
PUBLIC int init_8253A_timer(unsigned freq)
\end{Verbatim}
Инициализирует канал 0 таймера 8253A устанавливая частоту 60 гц, регистрирует обработчик прерываний задания CLOCK для выполнения каждый тик.

\begin{Verbatim}[frame=single]
PUBLIC void stop_8253A_timer(void)
\end{Verbatim}
Сбрасывает частоту таймера на значение BIOS (Для перезагрузки.)

\begin{Verbatim}[frame=single]
PUBLIC clock_t read_8253A_timer(void)
\end{Verbatim}
Считывает счётчик по каналу 0 таймера 8253A. Счётчик отсчитывает в обратном порядке с частотой TIMER\_FREQ и возвращается в значение TIMER\_COUNT-1 , когда достигает нулевого значения. Аппаратное прерывание (тик) возникает в момент, когда счётчик достигает нулевого значения и возобновляет свой цикл.

\textbf{do\_int86.c (4.0K)} -- Реализуется вызов микроядра SYS\_INT86.

Параметры:
\begin{itemize}
\item INT86\_REG86
\end{itemize}

\textbf{do\_iopenable.c (4.0K)} -- Реализуется вызов микроядра SYS\_IOPENABLE.

Параметры:
\begin{itemize}
\item IO\_ENDPT -- Процесс, которому устанавливаются биты уровня защиты ввода/вывода.
\end{itemize}

\textbf{do\_readbios.c (4.0K)} -- Реализуется вызов микроядра SYS\_READBIOS (Получает данные BIOS.)

Параметры:
\begin{itemize}
\item RDB\_SIZE -- Число байт, которые надо скопировать
\item RDB\_ADDR	-- Абсолютный адрес в зоне BIOS.
\item RDB\_BUF -- Адрес буфера в запрашивающем процессе.
\end{itemize}


\textbf{do\_sdevio.c (4.0K)} -- Реализуется вызов микроядра SYS\_SDEVIO (Доступ к портам ввода/вывода.)

Параметры:
\begin{itemize}
\item DIO\_REQUEST -- Запрос на вывод или ввод.
\item DIO\_PORT -- Порт для  чтения/записи.
\item DIO\_VEC\_ADDR -- Виртуальный адрес буфера или ID разрешения.
\item DIO\_VEC\_SIZE -- Число элементов.
\item DIO\_VEC\_PROC -- Процесс, в котором находится буфер.
\item DIO\_OFFSET -- Смещение в разрешении.
\end{itemize}

\textbf{exception.c (4.0K)} -- Этот файл содержит простой обработчик исключений. Исключения в пользовательских процессах преобразуются в сигналы. Исключения в заданиях микроядра вызывают панику (и прерывание работы Minix3).

\textbf{i8259.c (8.0K)} -- Этот файл содержит процедуры для инициализации контроллера прерываний 8259:
\begin{itemize}
\item put\_irq\_handler -- регистрирует обработчик прерываний
\item rm\_irq\_handler -- удаляет обработчик прерываний из регистра
\item intr\_handle -- обрабатывает аппаратное прерывание,
\item intr\_init -- осуществляет инициализацию контроллера (контроллеров) прерываний.
\end{itemize}

\textbf{klib386.S (8.0K)} -- Этот файл содержит ассемблерный код процедур, необходимых для микроядра:
\begin{Verbatim}[frame=single]
void monitor()	/* выйти из Minix и возвратиться в монитор*/
void int86()	/* позволить монитору выполнить прерывание 8086*/
exit	/* заглушки для библиотечных процедур */
main  /* заглушка для GCC */
void phys_insw(Port_t port, phys_bytes buf, size_t count) /* перемещает данные с (контроллера диска) порта в память */
void phys_insb(Port_t port, phys_bytes buf, size_t count)	/* тоже – по байтам */
void phys_outsw(Port_t port, phys_bytes buf, size_t count)	/* перемещает данные из памяти в (контроллер диска) порт */
void phys_outsb(Port_t port, phys_bytes buf, size_t count)	/* тоже – по байтам */
phys_bytes phys_copy(phys_bytes source, phys_bytes destination, phys_bytes bytecount)	/* копирует данные из любой области памяти в любую область памяти */
phys_copy_fault /*точка входа: страничное исключение phys_copy*/
phys_copy_fault_in_kernel /* точка входа: страничное исключение phys_copy в ядре*/
phys_memset(phys_bytes source, unsigned long pattern, phys_bytes bytecount)	/* пишет (байт(?)) образец в любую область памяти*/
u16_t mem_rdw(U16_t segment, u16_t *offset)	/* копирует одно слово с [segment:offset] */
void reset()	/* reset the system – системный сброс*/
idle_task	/* точка входа: задание выполняемое когда нет работы */
void level0(void (*func)(void))	/* вызвать функцию на уровне 0 */
unsigned long read_cpu_flags(void)	/* прочесть флаги процессора */
\end{Verbatim}

Эти процедуры гарантирую сохранение только тех регистров, сохранение которых требует компилятор C: (ebx, esi, edi, ebp, esp, сегментные регистры, регистр флагов).

\textbf{memory.c (16K)} -- Внутренние функции виртуальной памяти (VM)

\textbf{mpx386.S (32K)} -- Файл mpx386.s включается mpx.s когда Minix компилируется для 32-х битного процессора Intel. Альтернативный mpx88.s включается для 16-битного процессора.

Этот файл является наиболее низкоуровневой частью Minix (наряду с /kernel/proc.c). Здесь осуществляется переключение процессов и поддержка обработки сообщений. Кроме того здесь содержаться обработчики 32-х битных прерываний и ассемблерный стартовый код (обеспечивает кооперацию с /kernel/start.c для обеспечения хорошего начального окружения для main()).

Каждый переход в микроядро происходит через данный файл. Входы в микроядро могут быть вложенными. Начальный вход может быть вызван системным вызовом (вызовом микроядра -- при попытке послать или получить сообщение), исключением или аппаратным прерыванием; вложенный (повторный) вход в микроядро может осуществляться только аппаратными прерываниями. Число вхождений в микроядра (степень вложенности) хранится в переменной k\_reenter. Важными моментами являются переключение на стек ядра и защита кода передачи сообщений /kernel/proc.c.

\textbf{protect.c (8.0K)} -- Этот файл содержит код для инициализации защищённого режима процессора, инициализации дескрипторов сегментов кода и данных и для инициализации глобальных дескрипторов для локальных дескрипторов в таблице процессов.

\textbf{proto.h (4.0K)} -- Содержит прототипы для:
\begin{itemize}
\item обработчиков аппаратных прерываний,
\item обработчиков исключений,
\item обработчиков программных прерываний,
\item прототипов функций из файлов
\begin{itemize}
\item /kernel/arch/i386/memory.c
\item /kernel/arch/i386/exception.c
\item /kernel/arch/i386/klib386.S
\item /kernel/arch/i386/protect.c
\end{itemize}
\item прототипов для работы с таблицей векторов прерываний.
\end{itemize}

\textbf{sconst.h (4.0K)} -- В данном файле содержаться различные константы, используемые в ассемблерном коде:
\begin{itemize}
\item размер машинного слова,
\item смещения в struct proc (должен быть согласован с /kernel/proc.h),
\item смещение на указатель текущего процесса сразу после прерывания, в предположении, что мы всегда имеем код ошибки в стеке, макросы (ассемблерного характера) связанные с сохранением контекста (в случае аппаратных прерываний).
\end{itemize}

\textbf{system.c (16K)} -- Системно зависимые функции для использования в микроядре в целом.