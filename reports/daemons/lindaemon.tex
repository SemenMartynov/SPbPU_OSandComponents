\newpage
\section{Фоновые приложения в Linux}

\subsection{Понятие процесса и демона}

В любой многозадачной системе одновременно может быть запущено много программ, то есть много процессов. В действительности в каждый момент времени выполняется только один процесс. Ядро (по средствам планировщика) выделяет каждому процессу небольшой квант времени и по истечении этого кванта передает управление следующему процессу. Кванты времени, выделяемые каждому процессу, на столько малы, что у пользователя создается иллюзия одновременного выполнения многих процессов. Для организации переключения между процессами по истечении кванта времени, выполняется фиксация и сохранение в памяти состояния программы. Этот снимок содержит информацию о состоянии регистров центрального процессора на момент прерывания программы, указание на то, с какой команды возобновить исполнение программы (состояние счетчика команд), содержимое стека и подобные данные. Когда процесс снова получает в свое распоряжение ЦП, состояние регистров ЦП и стека восстанавливается из сделанного снимка и выполнение программы возобновляется в точности с того места, где она была остановлена. Такие же действия выполняются в тех случаях, когда какому-то процессу необходимо вызвать некоторую системную функцию (вызов ядра)\cite{Cit1}.

Кроме организации переключения процессов, ядро в многозадачной системе отвечает за изоляцию процессов -- два процесса не должны одновременно изменять какие-то данные одном участке памяти. Для этого каждому процессу выделяется свое виртуальное адресное пространство. Его размер может даже превышать размер реальной оперативной памяти, что обеспечивается за счет применения страничной организации памяти и механизма свопинга. И физическая и виртуальная память организована в виде страниц -- областей памяти фиксированного размера (обычно 4 Кбайта). Если страница долго не используется, ее содержимое переносится в область свопинга на жестком диске, а страница в оперативной памяти предоставляется в распоряжение другого процесса. Подсистема управления памятью поддерживает таблицу соответствия между страницами виртуальной памяти процессов и страницами физической памяти (включая страницы, перенесенные в область свопинга). В современных компьютерных системах эти механизмы реализуются на аппаратном уровне с помощью устройств управления памятью -- Memory Management Unit (MMU). Если процесс обращается к странице виртуальной памяти, которая размещается в оперативной памяти, операция чтения или записи осуществляется немедленно. Если же страница в оперативной памяти отсутствует, генерируется аппаратное прерывание, в ответ на которое подсистема управления памятью определяет положение сохраненного содержимого страницы в области свопинга, считывает страницу в оперативную память, корректирует таблицу отображения виртуальных адресов в физические, и сообщает процессу о необходимости повторить операцию. Все эти действия невидимы для приложения, которое работает с виртуальной памятью. При этом один процесс не может прочитать что-либо из памяти (или записать в нее) другого процесса без «разрешения» на то со стороны подсистемы управления памятью. При такой организации работы крах одного процесса никак не повлияет на другие выполняющиеся процессы и на всю систему в целом.

Среди всех процессов можно выделить несколько особых типов процессов.

Системные процессы являются частью ядра и всегда находятся в оперативной памяти. Такие процессы не имеют соответствующих им программ в виде исполняемых файлов и запускаются особым образом при инициализации ядра системы. Примерами системных процессов являются планировщик процессов, диспетчер свопинга, диспетчер буферного кэша, диспетчер памяти ядра. Такие процессы являются фактически потоками ядра.

Демоны отличаются от обычных процессов только тем, что они работают в интерактивном режиме. Если с обычным процессом всегда ассоциирован какой-то терминал или псевдо терминал, через который осуществляется взаимодействие процесса с пользователем, то демон такого терминала не имеет. Демоны обычно используются для выполнения сервисных функций, обслуживания запросов от других процессов, причем не обязательно выполняющихся на данном компьютере. Пользователь не может непосредственно управлять демонами, он может влиять на их работу, только посылая им какие-то задания, например, отправляя документ на печать.

Главным демоном в системе является демон init\cite{Cit2}. Он является прародителем всех процессов в системе и имеет идентификатор 1. Выполнив задачи, поставленные в ему в файле inittab, демон init не завершает свою работу -- он постоянно находится в памяти и отслеживает выполнение других процессов.

Прикладные процессы -- это все остальные процессы, выполняющиеся в системе. Как правило, эти процессы порождаются в рамках сеанса работы пользователя. В каждом таком сеансе работы вначале запускается оболочка (командный интерпретатор) shell. Этот экземпляр оболочки называется login shell и завершение соответствующего процесса приводит к отключению пользователя от системы.

\subsection{Создание демона Linux}

Для задачи демонизации будем использовать программу из предыдущей лабораторной работы. Она будет отслеживать состояние сетевого интерфейса и записывать результаты своей работы в системный журнал. Код демона представлен в листинге 1.

\lstinputlisting[language=C++, caption={Исходный код демона Linux (src/daemons/lin/main.cpp)}]
{../../src/daemons/lin/main.cpp}

Логика работы самого приложения не изменилась, изменился только способ запуска. После проверки аргументов (стр. 19), приложение выполняет операцию fork() (стр. 24), после чего "родительская" часть спокойно завершает свою работу (стр. 59), а "дочернее" выполняет ряд операций, характерных для демона.

Для начала в процессе потомка нужно разрешить выставлять все биты прав на создаваемые файлы, это избавляет от проблемы с правами доступа (стр. 27). Потом создаётся новый сеанс, чтобы не зависеть от родителя (стр. 28). Далее осуществляется переход в корень диска, если этого не сделать, то могут быть проблемы, к примеру с размонтированием дисков (стр. 29). И в конце происходит закрытие дескрипторов ввода/вывода/ошибок, так как демону они не понадобятся (стр. 30-32).

После запуска демона, убедиться в его работоспособности можно так

\begin{Verbatim}[frame=single]
user@host$ ps aux | grep netmonitor 
sam       5776 31.0  0.0  13528   180 ?        Ss   21:25   0:13 ./netmonitor enp2s0
user@host$
\end{Verbatim}

\subsection{Работа с системным журналом}

Функция системного журналирования (т.н. "логи" или логирование) -- это основной источник информации о работе системы и ошибках. Журналирование может осуществляться на локальной системе, а так же сообщения журналирования могут пересылаться на удаленную систему. Журналирование осуществляется при помощи демона syslogd или rsyslogd. Журнал обычно получает входную информацию при помощи сокета /dev/log (локально) или с udp-порта 514 (с удаленных машин)\cite{Cit3}.

Соединение с журналом было установлено в строке 18. Первый параметр сообщил системному журналу имя приложения, которое будет использоваться при ведении записей, а два оставшихся поля состоят из флагов флагов\cite{Cit2}.

Предпоследнее поле (option) принимает дизъюнкцию следующих значений:
\begin{itemize}
\item \textbf{LOG\_CONS} написать сообщение об ошибке прямо на консоли, если была ошибка при записи данных в системный журнал; 
\item \textbf{LOG\_NDELAY} устанавливать соединение немедленно (обычно оно устанавливается только при поступлении первого сообщения); 
\item \textbf{LOG\_NOWAIT} не ожидает дочерние процессы которые могут быть созданы во время отправки этого сообщения
\item \textbf{LOG\_ODELAY}обратно от LOG\_NDELAY; открытие соединения откладывается до вызова syslog(). 
\item \textbf{LOG\_PERROR} посылать сообщение еще и в поток stderr; 
\item \textbf{LOG\_PID} добавлять к каждому сообщению идентификатор 
\end{itemize}

Последнее поле (facility) используется для указания типа программы, записывающей сообщения и принимает дизъюнкцию следующих значений:
\begin{itemize}
\item \textbf{LOG\_AUTH} сообщения о безопасности/авторизации (РЕКОМЕНДУЕТСЯ использовать вместо него LOG\_AUTHPRIV). 
\item \textbf{LOG\_AUTHPRIV} сообщения о безопасности/авторизации (частные); 
\item \textbf{LOG\_CRON} демон часов (cron и at); 
\item \textbf{LOG\_DAEMON} другие системные демоны; 
\item \textbf{LOG\_KERN} сообщения ядра; 
\item \textbf{LOG\_LOCAL0 до LOG\_LOCAL7} зарезервированы для определения пользователем; 
\item \textbf{LOG\_LOG\_LPR} подсистема принтера; 
\item \textbf{LOG\_MAIL} почтовая подсистема; 
\item \textbf{LOG\_NEWS} подсистема новостей USENET; 
\item \textbf{LOG\_SYSLOG} сообщения, генерируемые syslogd; 
\item \textbf{LOG\_USER} (по умолчанию) -- общие сообщения на уровне пользователя;
\item \textbf{LOG\_UUCP} -- подсистема UUCP 
\end{itemize}

При записи сообщения, можно указать его тип (критичность) для последующей фильтрации (показывать сообщения не ниже определённого уровня). Это используется в строках 20, 42, 46, 56, 60.

Уровень важности сообщения по понижению:

\begin{itemize}
\item \textbf{LOG\_EMERG} система остановлена; 
\item \textbf{LOG\_ALERT} требуется немедленное вмешательство; 
\item \textbf{LOG\_CRIT} критические условия; 
\item \textbf{LOG\_ERR} ошибки; 
\item \textbf{LOG\_WARNING} предупреждения; 
\item \textbf{LOG\_NOTICE} важные рабочие условия; 
\item \textbf{LOG\_INFO} информационные сообщения; 
\item \textbf{LOG\_DEBUG} сообщения об отладке.
\end{itemize}

В строке 64 соединение с системным логом закрывается.

Записи системного лога попадают в файл /var/log/syslog. В листинге 2 показан вывод (без форматирования) некоторых (10 последних) строк этого файла. Важно отметить, что когда системный журнал получает повторяющиеся события (т.е. состояние счётчиков на сетевой карте не успело измениться), он делает пометку о повторе, вместо прямого дублирования.

\lstinputlisting[language={},caption={Системный журнал Linux}]{res/syslog.output}
