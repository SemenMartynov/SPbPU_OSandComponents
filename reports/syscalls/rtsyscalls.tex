\newpage
\section{Системные вызовы процессов реального времени}

Для изучения системных вызовов sched\_setparam, sched\_getparam и sched\_rr\_get\_interval целесообразно рассмотреть всю группу системных вызовов, позволяющих процессу менять его дисциплину планирования и, в частности, становиться процессом реального времени. Процесс должен иметь способность CAP\_SYS\_NICE (т.е. способностью изменять приоритет чужих процессов), чтобы модифицировать значения полей rt\_priority и policy у дескриптора любого процесса, включая собственный.

Системный вызов \textbf{sched\_getscheduler} запрашивает политику планирования, действующую в отношении процесса, идентифицируемого параметром pid. Если значение pid во время вызова равен 0, считывается политика вызвавшего процесса. В случае успеха системный вызов возвращает политику sched\_fifo, sched\_rr или sched\_normal (последняя также называется sched\_other). Соответствующая служебная процедура sys\_sched\_getscheduier вызывает функцию find\_process\_by\_pid, которая находит дескриптор процесса по переданному значению pid и возвращает значение его поля policy.

Системный вызов \textbf{sched\_setscheduier} устанавливает как политику планирования, так и соответствующие параметры для процесса, идентифицируемого параметром pid. Как и в случае с sched\_getscheduler, если pid равен 0, то устанавливаются параметры планировщика, применяемые к вызвавшему процессу. Соответствующая служебная процедура sys\_sched\_setscheduler вызывает функцию do\_sched\_setscheduler. Эта функция проверяет допустимость политики планирования, определяемой параметром policy, и нового приоритета, определяемого параметром param->sched\_priority. Она также проверяет, есть ли у процесса способность CAP\_SYS\_NICE, или наличие прав суперпользователя у его владельца. Если все в порядке, она удаляет процесс из очереди на выполнение (если он выполняемый), обновляет статический и динамический приоритеты и приоритет реального времени у процесса, возвращает процесс в очередь на выполнение и, если необходимо, вызывает функцию resched\_task для вытеснения текущего процесса, принадлежащего данной очереди.

Системный вызов \textbf{sched\_getparam} читает параметры процесса, идентифицируемого параметром pid. Если pid равен 0, считываются параметры текущего процесса. Соответствующая служебная процедура sys\_sched\_getparam, как и следует ожидать, находит указатель на дескриптор процесса по параметру
pid, сохраняет поле rt\_priority в локальной переменной типа sched\_param и вызывает функцию copy\_to\_user, чтобы скопировать это значение в адресное пространство процесса, по адресу, заданному параметром param.

Системный вызов \textbf{sched\_setparam} аналогичен вызову sched\_setscheduler, различие состоит в том, что sched\_setparam не позволяет вызвавшему процессу задавать значение поля policy. Соответствующая служебная процедура sys\_sched\_setparam вызывает функцию do\_sched\_setscheduler практически с теми же параметрами, что и служебная процедура sys\_sched\_setscheduler.

Системный вызов \textbf{sched\_yieido} позволяет процессу добровольно освободить процессор без приостановки своего выполнения. Процесс остается в состоянии TASK\_RUNNING, а планировщик заносит его либо в набор процессов с истекшими квантами времени (если это обычный процесс), либо в конец списка в очереди на выполнение (если это процесс реального времени). Затем вызывается функция schedule. В результате у других процессов с тем же динамическим приоритетом появляется возможность поработать. Данный вызов используется, в основном, процессами реального времени, принадлежащими классу SCHED\_FIFO.

Системные вызовы \textbf{sched\_get\_priority\_min} и \textbf{sched\_get\_priority\_max} возвращают, соответственно, минимальный и максимальный статический приоритет реального времени, который может быть использован при проведении политики планирования, идентифицируемой параметром policy. Служебная процедура sys\_sched\_get\_priority\_min возвращает 1, если текущий процесс является процессом реального времени, и 0 в противном случае. Служебная процедура sys\_sched\_get\_priority\_max возвращает 99 (наивысший приоритет), если текущий процесс является процессом реального времени, и 0 в противном случае.

Системный вызов \textbf{sched\_rr\_get\_interval} записывает в структуру, хранящуюся в адресном пространстве режима пользователя, квант времени, соответствующий круговому принципу работы, для процесса реального времени, идентифицируемого параметром pid. Если pid равен 0, системный вызов записывает квант времени текущего процесса. Как и в предыдущих примерах, соответствующая служебная процедура sys\_sched\_rr\_get\_interval вызывает функцию find\_process\_by\_pid, для получения дескриптора процесса по значению pid. Затем она преобразует базовый квант времени выбранного процесса в секунды и наносекунды, и копирует эти числа в структуру пользовательского режима. В соответствии с соглашением, временной квант процесса реального времени, принадлежащего классу "первым вошел — первым вышел", равен нулю.